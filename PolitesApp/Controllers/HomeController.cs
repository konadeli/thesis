using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using CryptoExpt;
using MailKit.Net.Smtp;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Cryptography.KeyDerivation;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Rendering;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using MimeKit;
using Users.Integrations;
using Users.ViewModel;
using ErrorViewModel = Users.Models.ErrorViewModel;
using Org.BouncyCastle.Asn1.Sec;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Security;
using Users.Models.Messages;
using Users.Models.User;

namespace Users.Controllers
{
    public class HomeController : Controller
    {
        private readonly ILogger<HomeController> _logger;
        private readonly UserManager<AspNetUsers> _userManager;
        private readonly IUserDbIntegration _userDbIntegration;
        private readonly IAadeDbIntegration _aadeDbIntegration;
        private readonly IMessageDbIntegration _messageDbIntegration;
        private readonly IConfiguration _configuration;

        public HomeController(
            IConfiguration configuration,
            UserManager<AspNetUsers> userManager,
            IUserDbIntegration userDbIntegration,
            IAadeDbIntegration aadeDbIntegration,
            IMessageDbIntegration messageDbIntegration,
            ILogger<HomeController> logger)
        {
            _userManager = userManager;
            _userDbIntegration = userDbIntegration;
            _aadeDbIntegration = aadeDbIntegration;
            _messageDbIntegration = messageDbIntegration;
            _logger = logger;
            _configuration = configuration;
        }

        [Authorize]
        public IActionResult Index()
        {
            var id = _userManager.GetUserId(User);
            var user = _userDbIntegration.GetUser(id);
            // first time there is no SALT so generate a random one which is
            // used every time afterwards

            if (string.IsNullOrEmpty(user.Salt))
            {
                var saltString = Guid.NewGuid();
                user.Salt = saltString.ToString();
                _userDbIntegration.UpdateUser(user);
            }

            List<SelectListItem> AadeUsers = _aadeDbIntegration.GetAadeUsers().Select(
                a => new SelectListItem
                {
                    Value = a.AadeUserId,
                    Text = a.Email
                }).ToList();



            var model = new HomeViewModel { AadeUsers = AadeUsers };

            model.ShowPasswordEntry = string.IsNullOrEmpty(user.SigningPassword);

            return View(model);
        }

        [Authorize]
        [HttpPost]
        public IActionResult Create(HomeViewModel model)
        {
            var id = _userManager.GetUserId(User);
            var user = _userDbIntegration.GetUser(id);

            if (model.MyDocument == null)
            {
                Response.StatusCode = 400;
                return Content("Select a document");
            }

            if (string.IsNullOrEmpty(user.SigningPassword) &&
            string.IsNullOrEmpty(model.Password))
            {
                Response.StatusCode = 400;
                return Content("A password is needed to create a unique signature for your document");
            }

            if (string.IsNullOrEmpty(user.SigningPassword) &&
                !string.IsNullOrEmpty(model.Password))
            {
                user.SigningPassword = model.Password;
                _userDbIntegration.UpdateUser(user);
            }

            if (model.MyDocument != null)
            {

                if (model.MyDocument.Length > 0)
                {
                    // https://blog.todotnet.com/2018/02/public-private-keys-and-signing/
                    using (var ms = new MemoryStream())
                    {
                        model.MyDocument.CopyTo(ms);
                        var array = ms.ToArray();

                        // Create a derived key from two pieces of information: the salt (the user's unique ID generated by the system), and a strong password known only to the user. PBKDF2 is used
                        // https://cryptobook.nakov.com/mac-and-key-derivation/pbkdf2
                        var salt = Encoding.ASCII.GetBytes(user.Salt);
                        var derivedKeyBytes = KeyDerivation.Pbkdf2(user.SigningPassword, salt, KeyDerivationPrf.HMACSHA256, 10000, 16);
                        var derivedKey = ByteArrayToString(derivedKeyBytes);
                        Console.WriteLine("Derived Key: " + derivedKey + Environment.NewLine);

                        // get a public signing key from the derived key
                        var publicKey = GetPublicKeyFromPrivateKeyEx(derivedKeyBytes);

                        // now create a one-time key for the symmetric encryption of this message
                        var oneTimeKeyBytes = KeyDerivation.Pbkdf2(user.SigningPassword, Encoding.ASCII.GetBytes(Guid.NewGuid().ToString()), KeyDerivationPrf.HMACSHA256, 10000, 16);
                        var oneTimeKey = ByteArrayToString(oneTimeKeyBytes);


                        // AES symmetric encryption of document
                        // https://www.c-sharpcorner.com/article/encryption-and-decryption-using-a-symmetric-key-in-c-sharp/
                        var encryptedString = AesOperation.EncryptString(oneTimeKey, Convert.ToBase64String(array));

                        var message = new Document
                        {
                            FromPublicKey = publicKey,
                            EncryptedDocument = encryptedString
                        };

                        // next the asymmetric encryption using AADE users public key
                        // use it to ENCRYPT the one-time symmetric key. Now the one-time key can ONLY be decrypted by the AADE recipient, because only they have the private key

                        // first get the public key which is saved in a serialized form so must be converted back into a key object
                        var aadeUserPublicKey = _aadeDbIntegration.GetAadeUserPublicKey(model.AadeUserId);
                        RsaKeyParameters publicKeyRecovered = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(aadeUserPublicKey));

                        // now ready to encrypt
                        // https://www.programmersought.com/article/7949780760/
                        IAsymmetricBlockCipher engine = new RsaEngine();
                        engine.Init(true, publicKeyRecovered);
                        var derivedKeyBytesToShare = engine.ProcessBlock(oneTimeKeyBytes, 0, oneTimeKeyBytes.Length);
                        message.EncryptedSymmetricKey = derivedKeyBytesToShare;
                        message.EncryptedSymmetricKeyLength = derivedKeyBytesToShare.Length;

                        var messageToSave = new Messages();
                        //Create a ECDSA signature using secp256k1 curve and SHA256 and add to message
                        //https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-examples
                        messageToSave.Signature = GetSignature(derivedKeyBytes, Convert.ToBase64String(array));
                        Console.WriteLine("Signature: " + messageToSave.Signature + Environment.NewLine);


                        // save to DB

                        messageToSave.UsersPublicKey = publicKey;
                        messageToSave.Message = message.Serialize();
                        messageToSave.AadeuserId = model.AadeUserId;
                        messageToSave.DateCreated = DateTime.UtcNow;
                        messageToSave.DateModified = DateTime.UtcNow;
                        messageToSave.PolitisUserId = id;
                        messageToSave.Status = 0;
                        messageToSave.Id = Guid.NewGuid().ToString();
                        messageToSave.FileName = Path.GetFileName(model.MyDocument.FileName);
                        messageToSave.ContentType = model.MyDocument.ContentType;

                        _messageDbIntegration.CreateMessage(messageToSave);

                        // notify AADE user by email
                        var aaudeUserEmailAddress = _aadeDbIntegration.GetAadeUserEmailAddress(model.AadeUserId);
                        SendEmail(aaudeUserEmailAddress);
                    }
                }
            }
            // to do  : Return something
            return RedirectToAction("Index", "Home");
        }


        public IActionResult Privacy()
        {
            return View();
        }

        [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
        public IActionResult Error()
        {
            return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
        }

        private void SendEmail(AadeUser user)
        {
            var mailMessage = new MimeMessage();
            mailMessage.From.Add(new MailboxAddress("DeliDoc", "aadedelidoc@gmail.com"));
            mailMessage.To.Add(new MailboxAddress(user.AadeUserName, user.Email));
            mailMessage.Subject = "Αρχείο από DeliDoc ";
            mailMessage.Body = new TextPart("html")
            {
                Text = "<b>Έχεις αρχείο από DeliDoc</b>"
            };

            using var client = new SmtpClient();
            client.Connect("smtp.gmail.com", 587, false);

            client.Authenticate("aadedelidoc", _configuration["pwd"]);

            client.Send(mailMessage);
            client.Disconnect(true);
        }


        private static string ByteArrayToString(byte[] ba)
        {
            string hex = BitConverter.ToString(ba);
            return hex.Replace("-", "");
        }

        private static string GetPublicKeyFromPrivateKeyEx(byte[] privateKey)
        {
            var curve = SecNamedCurves.GetByName("secp256k1");
            var domain = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);

            var d = new Org.BouncyCastle.Math.BigInteger(privateKey);
            var q = domain.G.Multiply(d);

            var publicKey = new ECPublicKeyParameters(q, domain);
            return Base58Encoding.Encode(publicKey.Q.GetEncoded());
        }

        private static string GetSignature(byte[] privateKey, string message)
        {
            var curve = SecNamedCurves.GetByName("secp256k1");
            var domain = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);

            var keyParameters = new
                ECPrivateKeyParameters(new Org.BouncyCastle.Math.BigInteger(privateKey),
                    domain);

            var signer = SignerUtilities.GetSigner("SHA-256withECDSA");

            signer.Init(true, keyParameters);
            signer.BlockUpdate(Encoding.ASCII.GetBytes(message), 0, message.Length);
            var signature = signer.GenerateSignature();
            return Base58Encoding.Encode(signature);
        }
    }
}